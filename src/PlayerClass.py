import pygamefrom src.ConfigSound import jump_sound, jump_out, run, exit_fximport randomfrom src.ConfigSound import fall, golem_diefrom src.WorldClass import exit_group, cut_group, blob_group, bullet_groupfrom src.config_screen import screen_from src.func import draw_textimport sysexit_fx = exit_fx()fall_fx = fall()run_fx = run()golem_die_fx = golem_die()jump_out_fx = jump_out()jump_fx = jump_sound()screen_width = 1100screen_height = 900screen = screen_()font = pygame.font.SysFont('Bauhaus 93', 70)blue = (65, 105, 225)class Player:    """    Класс, представляющий игрока в платформере.    Атрибуты:    images_right (list): Список изображений для анимации игрока при движении вправо.    images_left (list): Список изображений для анимации игрока при движении влево.    index (int): Текущий индекс изображения для анимации.    counter (int): Счетчик для контроля частоты смены кадров анимации.    rect (pygame.Rect): Прямоугольник, определяющий размеры и положение игрока.    vel_y (int): Вертикальная скорость игрока.    jumped (bool): Флаг, указывающий, совершил ли игрок прыжок.    direction (int): Направление движения игрока (-1: влево, 1: вправо).    in_air (bool): Флаг, указывающий, находится ли игрок в воздухе.    """    def __init__(self, x, y):        """        Инициализирует(создает) объект игрока с заданными координатами.        Параметры:        x (int): Координата X начального положения игрока.        y (int): Координата Y начального положения игрока.        """        self.reset(x, y)        self.jump = False        self.run = False        self.game_over = 0        self.jump_s = jump_fx[0]        self.attack = False        self.attack_anim = False        self.indexP = 0    def update(self, world, fire):        """        Обновляет состояние игрока, обрабатывает ввод с клавиатуры и перемещает игрока.        """        dx = 0        dy = 0        walk_cooldown = 1  # Задержка между кадрами анимации        idle_cooldown = 5        punch_cooldown = 10        # Обработка нажатий клавиш для движения        if self.game_over == 0:            key = pygame.key.get_pressed()            if key[pygame.K_LEFT]:                dx -= 5  # Движение влево                self.counter += 1                self.direction = -1  # Направление влево                if not self.jumped and not self.in_air:                    try:                        if not fire:                            self.image = self.images_left[self.index]                        else:                            self.image = self.images_leftF[self.index]                    except IndexError:                        self.index = 0                if not self.run and not self.jump and not self.in_air:                    self.run = True                    if self.run:                        run_fx.play(-1)            if key[pygame.K_RIGHT]:                dx += 5  # Движение вправо                self.counter += 1                self.direction = 1                # Направление вправо                if not self.jumped and not self.in_air:                    try:                        if not fire:                            self.image = self.images_right[self.index]                        else:                            self.image = self.images_rightF[self.index]                    except IndexError:                        self.index = 0                if not self.run and not self.jump and not self.in_air:                    self.run = True                    if self.run:                        run_fx.play(-1)            if key[pygame.K_q]:                self.attack = True                self.attack_anim = True            else:                self.attack = False            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:                self.counter += 1                self.run = False                run_fx.stop()                # Установка изображения в зависимости от направления                # if not self.jumped and not self.in_air:                #     if not fire:                #         try:                #             if self.direction == 1:                #                 self.image = self.images_right_idle[self.index]                #             if self.direction == -1:                #                 self.image = self.images_left_idle[self.index]                #         except IndexError:                #             self.index = 0                #     else:                #         try:                #             if self.direction == 1:                #                 self.image = self.images_right_idle_f[self.index]                #             if self.direction == -1:                #                 self.image = self.images_left_idle_f[self.index]                #         except IndexError:                #             self.index = 0            # ------------------ переключение анимации --------------------- #            if self.attack_anim and fire:                if self.counterP > 1:                    self.counterP = 0                    self.indexP += 1                    if self.indexP >= len(self.images_right_punchF):                        self.indexP = 0                        self.attack = False                        self.attack_anim = False                    if self.direction == 1:                        self.image = self.images_right_punchF[self.indexP]                    if self.direction == -1:                        self.image = self.images_left_punchF[self.indexP]            if self.attack_anim and not fire:                if self.counterP > 1:                    self.counterP = 0                    self.indexP += 1                    if self.indexP >= len(self.images_right_punch):                        self.indexP = 0                        self.attack = False                        self.attack_anim = False                    if self.direction == 1:                        self.image = self.images_right_punch[self.indexP]                    if self.direction == -1:                        self.image = self.images_left_punch[self.indexP]            elif fire and not key[pygame.K_LEFT] and not key[                pygame.K_RIGHT] and not self.jumped and not self.attack_anim:                if self.counter > idle_cooldown:                    self.counter = 0                    self.index += 1                    if self.index >= len(self.images_right_idle_f):                        self.index = 0                    if self.direction == 1:                        self.image = self.images_right_idle_f[self.index]                    if self.direction == -1:                        self.image = self.images_left_idle_f[self.index]            elif not key[pygame.K_LEFT] and not key[                pygame.K_RIGHT] and not self.jumped and not fire and not self.attack_anim:                if self.counter > idle_cooldown:                    self.counter = 0                    self.index += 1                    if self.index >= len(self.images_right_idle):                        self.index = 0                    if self.direction == 1:                        self.image = self.images_right_idle[self.index]                    if self.direction == -1:                        self.image = self.images_left_idle[self.index]            elif not self.jumped and not self.in_air and not fire and not self.attack_anim:                if self.counter > walk_cooldown:                    self.counter = 0                    self.index += 1                    if self.index >= len(self.images_right):                        self.index = 0                    if self.direction == 1:                        self.image = self.images_right[self.index]                    if self.direction == -1:                        self.image = self.images_left[self.index]            elif not self.jumped and not self.in_air and fire and not self.attack_anim:                if self.counter > walk_cooldown:                    self.counter = 0                    self.index += 1                    if self.index >= len(self.images_rightF):                        self.index = 0                    if self.direction == 1:                        self.image = self.images_rightF[self.index]                    if self.direction == -1:                        self.image = self.images_leftF[self.index]            self.counterP += 1            # -----------------------------------------------------------#            if self.rect.x + dx >= screen_width - 18 or self.rect.x + dx <= 0:                dx = 0            # Обработка прыжка            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:                self.vel_y = -15                self.jumped = True                self.jump = True                self.run = False                run_fx.stop()                self.jump_s = random.choice(jump_fx)  # !!! воспроизводим звук прыжка                self.jump_s.play()            if not key[pygame.K_SPACE]:                self.jumped = False            # Применение гравитации            self.vel_y += 1            if self.vel_y > 10:                self.vel_y = 10            dy += self.vel_y            if self.vel_y < 0:                self.in_air = True                if fire:                    try:                        if self.direction == 1:                            self.image = self.images_right_jumpF[self.index]                        if self.direction == -1:                            self.image = self.images_left_jumpF[self.index]                    except IndexError:                        self.index = 0                else:                    try:                        if self.direction == 1:                            self.image = self.images_right_jump[self.index]                        if self.direction == -1:                            self.image = self.images_left_jump[self.index]                    except IndexError:                        self.index = 0            # Проверка столкновений с тайлами            for tile in world.tile_list:                # Проверка столкновений по X                if tile[1].colliderect(self.rect.x + dx, self.rect.y, self.width, self.height):                    dx = 0                # Проверка столкновений по Y                if tile[1].colliderect(self.rect.x, self.rect.y + dy, self.width, self.height):                    if self.vel_y < 0:                        dy = tile[1].bottom - self.rect.top                        self.vel_y = 0                    elif self.vel_y >= 0:                        dy = tile[1].top - self.rect.bottom                        self.vel_y = 0                        self.in_air = False                    if self.jump:                        jump_out_fx.play()                        self.jump = False            # Обновление координат игрока            self.rect.x += dx            self.rect.y += dy            if self.rect.bottom > screen_height:                self.rect.bottom = screen_height                dy = 0                self.in_air = False            if pygame.sprite.spritecollide(self, exit_group, False):                self.game_over = 1                run_fx.stop()                exit_fx.play()                self.jump_s.stop()            if pygame.sprite.spritecollide(self, cut_group, False):                fall_fx[0].play()                fall_fx[1].play()                run_fx.stop()                self.jump_s.stop()                self.reset(20, screen_height - 130)                self.game_over = -1            if self.attack_anim:                if pygame.sprite.spritecollide(self, blob_group, True):                    golem_die().play()            else:                if pygame.sprite.spritecollide(self, blob_group, False):                    self.game_over = -1                    run_fx.stop()                    self.jump_s.stop()            if pygame.sprite.spritecollide(self, bullet_group, True):                if self.Hp <= 0:                    self.game_over = -1                    run_fx.stop()                    self.jump_s.stop()                self.Hp -= 1            # Отрисовка игрока на экране            screen.blit(self.image, self.rect)    def reset(self, x, y):        """        Сбрасывает состояние игрока к начальным параметрам.        Параметры:        x (int): Координата X начального положения игрока.        y (int): Координата Y начального положения игрока.        """        self.images_right = []        self.Hp = 10        self.images_left = []        self.images_rightF = []        self.images_leftF = []        self.images_right_idle_f = []        self.images_left_idle_f = []        self.images_right_idle = []        self.images_left_idle = []        self.images_left_jumpF = []        self.images_right_jumpF = []        self.images_left_jump = []        self.images_right_jump = []        self.images_right_punchF = []        self.images_left_punchF = []        self.images_right_punch = []        self.images_left_punch = []        self.index = 0        self.counter = 0        self.counterP = 0        # Загрузка изображений игрока для анимации движения        for num in range(0, 6):            img_right = pygame.image.load(f'img\\sprite_{num}.png')            img_right = pygame.transform.scale(img_right, (35, 35))            img_left = pygame.transform.flip(img_right, True, False)            self.images_right.append(img_right)            self.images_left.append(img_left)        for num in range(0, 6):            img_right = pygame.image.load(f'img\\spriteWalkF{num}.png')            img_right = pygame.transform.scale(img_right, (35, 35))            img_left = pygame.transform.flip(img_right, True, False)            self.images_rightF.append(img_right)            self.images_leftF.append(img_left)        for num in range(0, 4):            img_right_idle = pygame.image.load(f'img\\spriteF{num}.png')            img_right_idle = pygame.transform.scale(img_right_idle, (35, 35))            img_left_idle = pygame.transform.flip(img_right_idle, True, False)            self.images_right_idle_f.append(img_right_idle)            self.images_left_idle_f.append(img_left_idle)        for num in range(0, 4):            img_right_idle = pygame.image.load(f'img\\spriteidle{num}.png')            img_right_idle = pygame.transform.scale(img_right_idle, (35, 35))            img_left_idle = pygame.transform.flip(img_right_idle, True, False)            self.images_right_idle.append(img_right_idle)            self.images_left_idle.append(img_left_idle)        for num in range(0, 2):            img_right_idle = pygame.image.load(f'img\\spriteJ{num}.png')            img_right_idle = pygame.transform.scale(img_right_idle, (35, 35))            img_left_idle = pygame.transform.flip(img_right_idle, True, False)            self.images_right_jumpF.append(img_right_idle)            self.images_left_jumpF.append(img_left_idle)        for num in range(0, 2):            img_right_idle = pygame.image.load(f'img\\Jump MC{num}.png')            img_right_idle = pygame.transform.scale(img_right_idle, (35, 35))            img_left_idle = pygame.transform.flip(img_right_idle, True, False)            self.images_right_jump.append(img_right_idle)            self.images_left_jump.append(img_left_idle)        for num in range(0, 8):            img_right = pygame.image.load(f'img\\Punch-outlineF\\sprite_{num}.png')            img_right = pygame.transform.scale(img_right, (35, 35))            img_left = pygame.transform.flip(img_right, True, False)            self.images_right_punchF.append(img_right)            self.images_left_punchF.append(img_left)        for num in range(0, 8):            img_right = pygame.image.load(f'img\\Punch-outline\\sprite_{num}.png')            img_right = pygame.transform.scale(img_right, (35, 35))            img_left = pygame.transform.flip(img_right, True, False)            self.images_right_punch.append(img_right)            self.images_left_punch.append(img_left)        self.dead_image = pygame.image.load('img\\ghost.png')        self.image = self.images_right[self.index]        self.rect = self.image.get_rect()        # Установка начальных координат и параметров игрока        self.rect.x = x        self.rect.y = y        self.width = self.image.get_width()        self.height = self.image.get_height()        self.vel_y = 0        self.jumped = False        self.direction = 0        self.in_air = True